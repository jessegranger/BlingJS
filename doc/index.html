<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<title>BlingJS Documentation</title>
		<script type="text/javascript" src="../dist/bling.js"></script>
		<style type="text/css">
			pre {
				padding-left: 10px;
			}
			code {
				padding: 2px 4px;
				background-color: #eaeaea;
				border-radius: 2px;
			}
			li {
				padding-top: 4px;
			}
		</style>
	</head>
	<body>
		<h1>BlingJS</h1>
		<p>The kitchen sink library.</p>
		<a name="basics"/>
		<h2>Basics</h2>
		<p>From the browser,</p>
		<pre>&lt;script src=".../bling.js"&gt;</pre>
		<p>or from Node,
		<pre>$ = require('bling')</pre>
		<p>By default, we take over the global variable <code>$</code>. If you don't want this:</p>
		<pre>$ = Bling.noConflict()</pre>
		<caption>This will restore <code>$</code> to whatever it was before, and the global
		<code>Bling</code> will remain.</caption>
		<a name="plugins"/>
		<h3>Plugins</h3>
		<p>Everything attached to <code>$</code> is built from plugins, so the only truly core
		functionality is for creating plugins and managing abstract dependencies.</p>
		<pre>$.plugin { provides: "answer" }, -&gt; { $: { answer: 42  } }</pre>
		<pre>$.answer === 42</pre>
		<caption>This is the simplest possible plugin.</caption>
		<p>There are many <a href="#plugin-list">plugins</a>.
		<a name="depends"/>
		<h3>Abstract Dependence</h3>
		<p>The <code>provides:</code> and <code>depends:</code> functionality seen above is provided by
		a pair of top-level functions that allow you to model any abstract set of dependencies as a set
		of tags (short strings).</p>
		<pre>$.depends "some string", someFunction</pre>
		<pre>$.provide "some string"</pre>
		<caption>Once <code>"some string"</code> gets provided, <code>someFunction</code> is
		called.</caption>
		<p>Data can also be passed with the <code>$.provide</code> call.</p>
		<pre>$.depends "tag", (data) -&gt; console.log data</pre>
		<pre>$.provide "tag", 42</pre>
		<caption>This will log, "42".</caption>
		<h5>Dependencies are not just callbacks or listeners</h5>
		<p>They only fire the one time, when they are first provided. Additional calls to
		<code>$.provide("tag")</code> for the same <code>"tag"</code> will be ignored.</p>
		<p>Calls to <code>$.depend("tag", func)</code> after <code>"tag"</code> has already been provided,
		will call <code>func</code> immediately.

		<a name="plugin-list">
		<h3>List of Functions - grouped by plugin</h3>
			<h4>Core Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/core.coffee">Source</a>
			</h4>
			<ol>
				<li><code>$.now</code> - the current time in ms.
				<li><code>$.assert(cond, message)</code> - assert that cond is true.
				<li><code>$.coalesce(items...)</code> - return the first non-null item.
				<li><code>$.keysOf(obj, own=false)</code> - shim for Object.keys(), <code>own=true</code>
				adds hasOwnProperty.
				<li><code>$.valuesOf(obj, own=false)</code> - complement to <code>$.keysOf()</code>
				<li><code>$(items).eq(i)</code> - return a new set with just the <code>i</code>-th item.
				<li><code>$(items).each(f)</code> - call f(item) for every item in this.
				<li><code>$(items).map(f)</code> - return a new set containing f(item) for every item.
				<li><code>$(items).every(f)</code> - true if f(item) is true for every item.
				<li><code>$(items).some(f)</code> - true if f(item) is true at least one item.
				<li><code>$(items).filterMap(f)</code> - like <code>$(items).map()</code> except omits
					<code>null</code> from the result. e.g.
					<pre>$(1,2,3).filterMap((x) -&gt; if (x%2) then x else null) == $(1, 3)</pre>
				<li><code>$(items).tap(f)</code> - call f(this) and continue chaining, e.g.
					<pre>$(items).tap($.log).hide()</pre>
				<li><code>$(items).reduce(f)</code> - Collect <code>a</code> from <code>f(a, item)</code> for every item. The <code>a</code> and <code>f</code> arguments can be given in any order.
					<pre>$(items).sum() == $(items).reduce 0, (a, x) -&gt; a + x</pre>
					<pre>$(items).product() == $(items).reduce 1, (a, x) -&gt; a * x</pre>
				<li><code>$(items).union(other, strict=true)</code> - Combine the two sets, eliminates duplicates.
				<li><code>$(items).intersect(other, strict=true)</code> - Return a new set with any overlapping items.
				<li><code>$(items).distinct(strict=true)</code> - Return a new set without any duplicates.
				<li><code>$(items).contains(item, strict=true)</code> - Return true if the item is in this set.
				<li><code>$(items).count(item, strict=true)</code> - The number of times item appears in this set.
				<li><code>$(items).coalesce()</code> - Return the first non-null item (descends recursively into nested arrays and blings).
				<li><code>$(items).or(value)</code> - Replace any false-y items with <code>value</code>.
				<li><code>$(items).swap(i,j)</code> - Swap the <code>i</code>-th and <code>j</code>-th item.
				<li><code>$(items).shuffle()</code> - Randomize the order, in-place.
				<li><code>$(items).select(property)</code> - Collect values from sets of objects. e.g.
					<pre>$(items).select('x') == $(items).map (item) -&gt; return item.x </pre>
					<p>You can also pass complex nested keys, descending into objects, arrays, etc.</p>
					<pre>$(items).select('someArray.2.someProperty')</pre>
					<p>Selecting functions will automatically bind those functions to the site they were selected from.</p>
					<pre>$(streams).select('write').call(data, "utf8")</pre>
				<li><code>$(items).zap(property, value)</code> - Assign <code>value</code> to <code>property</code> on every item in this.
					Supports the same complex, and nested, properties that <code>$(items).select(...)</code> does.
					<pre>$(items).zap('childNodes.2.style.display','none') # Hide every 3rd child</pre>
				<li><code>$(items).take(n)</code> - Return the first <code>n</code> items from this.
				<li><code>$(items).skip(n)</code> - Return everything except the first <code>n</code> items from this.
				<li><code>$(items).first(n=1)</code> - Return the first item (or the first n items if asked).
				<li><code>$(items).last(n=1)</code> - Return the last [n] item[s].
				<li><code>$(items).slice(start,end)</code> - Like Array.slice() except supports negative indices, e.g.
					<pre>$(items).slice(0, -2) == $(items).slice(0, items.length - 2)</pre>
				<li><code>$(items).extend(others)</code> - Append all the other items to this set (allows duplicates).
				<li><code>$(items).push(item)</code> - Append item and return this (allows chaining), e.g.
					<pre>$(items).push(1).push(2).reverse()</pre>
				<li><code>$(items).filter(func, limit=Infinity, positive=true)</code> - Select a new set where <code>f(item) is true</code>.
					<p>For example, passing <code>positive=false</code> inverts the meaning of the filter.
				<li><code>$(items).matches(expr)</code> - Filter the set to contain only items that:
					<ol>
						<li> If expr is a string, then items must be DOM nodes that match that string as a CSS selector.
						<li> If expr is a regexp, then items must be strings that match that regexp.
					</ol>
				</li>
				<li><code>$(items).weave(other)</code> - Interleave the items from the two sets.
					<pre>$(1,1,1).weave($(2,2,2)) == $(2,1,2,1,2,1)</pre>
				<li><code>$(items).fold(f)</code> - Stride over this set calling <code>f(a,b)</code> for each pair of items.
					<pre>$(1,2,3,4).fold( (a,b) -&gt; a + b ) == $(3, 7)</pre> 
					<caption>This is a complement to <code>$(items).weave()</code> and they can often be used together.</caption>
				<li><code>$(items).flatten()</code> - Flatten out any nested arrays.
					<pre>$( [1,2], [3,4] ).flatten() == $(1,2,3,4)</pre>
				<li><code>$(items).call(args...)</code> - Call every function in this set with <code>args...</code>.
				<li><code>$(items).apply(context, args...)</code> - Apply every function in this set.
				<li><code>$(items).log(prefix)</code> - Log this set to the global <code>$.log</code>.
				<li><code>$(items).toArray()</code> - Un-bling this set of items, returning back to a simple Array.
				<li><code>$(items).clear()</code> - Remove all items from this.
				<li><code>$(items).indexWhere(f)</code> - Return the first index where <code>f(item)</code> is true
			</ol>
			<h4>EventEmitter Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/EventEmitter.coffee">Source</a>
			</h4>
			<p>This provides the same basic interface as EventEmitter API in NodeJS. It becomes available
			on all Bling objects, as well as a base class to use in inheritance, as well as a global
			instance through which you can communicate.
			<ol>
				<li><code>.on('event', handler)</code>
				<li><code>.emit('event', args...)</code>
				<li><code>.addListener</code> - synonym for <code>.on</code>
				<li><code>.removeListener('event', [handler])</code>
				<li><code>.removeAllListeners('event')</code>
				<li><code>.listeners</code> - a copy of the set of listeners (modifying it is not equivalent
				to calling <code>.on(...)</code>)
				<li><code>class MyClass extends $.EventEmitter then constructor: -> super @</code>
				<li><code>$.EventEmitter.apply(object)</code>
			</ol>
			<p>Every Bling instance is an EventEmitter automatically.</p>
			<pre>$(items).on('data', $.log).emit('data')</pre>
			<p>$.EventEmitter is an instance of it's type.</p>
			<pre>$.EventEmitter.on('data', $.log).emit('data')</pre>

			<h4>Async Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/async.coffee">Source</a>
			</h4>
			<ol>
				<li><code>$(funcs).series(done)</code> - Call each function with a single argument, a
				callback function. It can be very helpful to use <code>$.partial()</code> here, to produce
				functions that only need the single callback as argument.
				<li><code>$(funcs).parallel(done)</code> - Similar to <code>series</code>, except start all
				the funcs at the same time. Each function still gets only the single callback.
			</ol>

			<h4>Cache Plugin - <a
			href="https://github.com/jldailey/BlingJS/blob/master/plugins/cache.coffee">Source</a>
			</h4>
			<p>Similar to EventEmitter, this provides <code>$.Cache</code> that is both an instance and a
			type. The cache supports TTLs and fixed capacities.
			<ol>
				<li><code>cache = new $.Cache(capacity, ttl)</code> - Create a new cache object.
				<li><code>cache.has(key)</code>
				<li><code>cache.del(key)</code>
				<li><code>cache.set(k, v, [ttl])</code>
				<li><code>cache.get(k)</code>
				<li><code>cache.clear()</code>
			</ol>
			<p><code>capacity</code> and <code>ttl</code> can both be <code>Infinity</code>.

			<h4>Compatibility Plugin - <a
			href="https://github.com/jldailey/BlingJS/blob/master/plugins/compat.coffee">Source</a>
			</h4>
			<p>This plugin provides all the various shims to make a minimal effort to unify the various
			platforms</p>
			<label>Shims</label>
			<ol>
				<li><code>$.global</code> - Same as 'window' in the browser, and 'global' in NodeJS.
				<li><code>$.global.Buffer</code> - If not defined, just add <code>Buffer.isBuffer -> false</code>
				<li><code>$.global.Map</code> - Fully functional shim for ES5 Map.
				<li><code>Math.sign(x)</code> - 1 if positive or 0, -1 otherwise
				<li><code>String::trimLeft</code>
				<li><code>String::split</code>
				<li><code>String::lastIndexOf</code>
				<li><code>Array::join(sep)</code>
				<li><code>Event::preventAll()</code>
				<li><code>Element::matchesSelector</code>
			</ol>

			<h4>Config Plugin - <a
			href="https://github.com/jldailey/BlingJS/blob/master/plugins/config.coffee">Source</a>
			</h4>
			<p>Read text files into <code>process.env</code> to manage configuration.</p>
			<ol>
				<li><code>$.config.get(name, default)</code> - Get a value from process.env, with a default.
				<li><code>$.config.set(name, value)</code>
				<li><code>$.config.parse(data)</code> - Parse '.env' style data into key/value pairs.
				<li><code>$.config.watch(name, cb)</code> - Call cb(prev, new) when the named value changes.
			</ol>

			<h4>Date Plugin - <a
			href="https://github.com/jldailey/BlingJS/blob/master/plugins/date.coffee">Source</a>
			</h4>
			<p>All date formats work with <code>$.date.parse()</code> and
			<code>$.date.dateFormat</code></p>
			<blockquote>
			<table>
				<tr><th>Date Format<th>Description
				<tr><td>yyyy<td>Year (4)
				<tr><td>YY (or yy)<td>Year (2)
				<tr><td>mm<td>Month (2)
				<tr><td>dd<td>Day of Month (2)
				<tr><td>dw<td>Day of week (1=monday)
				<tr><td>dW<td>Day of Week (Mon,Tue,etc)
				<tr><td>DW<td>Day of Week (Monday,Tuesday,etc)
				<tr><td>HH<td>Hour
				<tr><td>MM<td>Minutes
				<tr><td>SS<td>Seconds
				<tr><td>MS<td>Milliseconds
				<tr><td>_MS<td>MS (left padded with 0)
			</table>
			</blockquote>

			<p>Functions</p>

			<ol>
				<li><code>$.date.defaultUnit = "s"</code> - default units for timestamps if not specified.
				<li><code>$.date.defaultFormat = "yyyy-mm-dd HH:MM:SS"</code>
				<li><code>$.date.stamp([date],[unit])</code> - get an integer timestamp
				<li><code>$.date.unstamp(ts,[unit])</code> - convert to date object
				<li><code>$.date.convert(ts,fromUnit,toUnit)</code> - convert between time units
				<li><code>$.date.midnight(ts, [unit])</code> - truncate the ts to the nearest midnight
				<li><code>$.date.format(ts, [format], [unit])</code> - see format table above
				<li><code>$.date.parse(str, [format], [unit])</code> - see format table above
			</ol>

			<h4>Debug Plugin - <a
			href="https://github.com/jldailey/BlingJS/blob/master/plugins/debug.coffee">Source</a>
			</h4>
			<p>Useful debugging functions.</p>
			<ol>
				<li><code>$.debugStack(err)</code> - return a stack trace that includes code snippets.
				<li><code>$.protoChain(obj)</code> - return a list of all the objects in the __proto__ chain
				of an object.
			</ol>

			<h4>Delay Plugin - <a
			href="https://github.com/jldailey/BlingJS/blob/master/plugins/delay.coffee">Source</a>
			</h4>
			<p>The builtins <code>setTimeout</code> and <code>setInterval</code> have two problems in my
			opinion, the more serious being that events which get scheduled near each other in time end up
			having an undefined execution order, even if they have a well-defined prior schedule.

			<p>This plugin guarantees proper order or execution, and adds the ability to pause and resume
			intervals.

			<ol>
				<li><code>$.delay(ms, f)</code> - returns <code>{ cancel: -> }</code>
				<li><code>$.interval(ms, f)</code> - returns <code>{ cancel: -> pause: -> resume: ->
				}</code>
				<li><code>$.immediate(f)</code> - calls setImmediate or process.nextTick or
				setTimeout(f, 0)
			</ol>

			<h4>Diff Plugin - <a
			href="https://github.com/jldailey/BlingJS/blob/master/plugins/diff.coffee">Source</a>
			</h4>

			<ol>
				<li><code>$.stringDistance(a, b)</code> - the minimum edit distance between two strings.
				<li><code>$.stringDiff(a, b)</code> - the list of changes to transform a into b.
			</ol>

	</body>
</html>
