<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<title>BlingJS Documentation</title>
		<script type="text/javascript" src="../dist/bling.js"></script>
		<link href='https://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css' />
		<style type="text/css">
			pre {
				font-family: 'Inconsolata', monospace;
				background: #ffc;
				border-radius: 2px;
				padding: 6px 6px;
				margin: 2px 4px;
			}
			code {
				font-family: 'Inconsolata', monospace;
				color: white;
				background: #333;
				border-radius: 2px;
				padding: 2px 4px;
			}
			li {
				padding-top: 4px;
			}
			table tr td {
				border-top: 1px dashed black;
				margin: 0;
			}
			table tr td:first-child + td {
				padding-top: 4px;
			}
			table tr {
				margin: 0;
				padding: 0;
			}
			h4 {
				border-bottom: 1px solid black;
				padding-left: 0px;
			}
			h4:before {
				content: "* "
			}
		</style>
		<script type="text/javascript">
			$(document).ready(function() {
				$("see").each(function() {
					text = this.textContent
					$(this).replace("<a href='#"+text+"'>see: "+text+"</a>")
				})
			})
		</script>
	</head>
	<body>
<h1>BlingJS</h1>
<p>The kitchen sink library.</p>
<a name="basics"/>
<h2>Basics</h2>
<p>From the browser,</p>
<pre>&lt;script src=".../bling.js"&gt;</pre>
<p>or from Node,
<pre>$ = require('bling')</pre>
<p>By default, we take over the global variable <code>$</code>. If you don't want this:</p>
<pre>$ = Bling.noConflict()</pre>
<p>This will restore <code>$</code> to whatever it was before, and the global
<code>Bling</code> will remain.</p>
<a name="plugins"/>
<h3>Plugins</h3>
<p>Everything attached to <code>$</code> is built from plugins, so the only truly core
functionality is for creating plugins and managing abstract dependencies.</p>
<pre>$.plugin { provides: "answer" }, -&gt; { $: { answer: 42  } }</pre>
<pre>$.answer === 42</pre>
<p>This is the simplest possible plugin.</p>
<p>There are many <a href="#plugin-list">plugins</a>.
<a name="depends"/>
<h3>Abstract Dependence</h3>
<p>The <code>provides:</code> and <code>depends:</code> functionality seen above is provided by
a pair of top-level functions that allow you to model any abstract set of dependencies as a set
of tags (short strings).</p>
<pre>$.depends "some string", someFunction</pre>
<pre>$.provide "some string"</pre>
<p>Once <code>"some string"</code> gets provided, <code>someFunction</code> is
called.</p>
<p>Data can also be passed with the <code>$.provide</code> call.</p>
<pre>$.depends "tag", (data) -&gt; console.log data</pre>
<pre>$.provide "tag", 42</pre>
<p>This will log, "42".</p>
<h5>Dependencies are not just callbacks or listeners</h5>
<p>They only fire the one time, when they are first provided. Additional calls to
<code>$.provide("tag")</code> for the same <code>"tag"</code> will be ignored.</p>
<p>Calls to <code>$.depend("tag", func)</code> after <code>"tag"</code> has already been provided,
will call <code>func</code> immediately.

<a name="plugin-list">
<h3>List of Functions - grouped by plugin</h3>
<h4>Core Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/core.coffee">Source</a>
</h4>
<table>
<a name="$.now"></a>
<tr><td valign=top><li><code>$.now</code><td>The current time in ms.
<a name="$.assert(cond, message)"></a>
<tr><td valign=top><li><code>$.assert(cond, message)</code><td>Assert that cond is true.
<a name="$.coalesce(items...)"></a>
<tr><td valign=top><li><code>$.coalesce(items...)</code><td>Return the first non-null item.
<a name="$.keysOf(obj, own=false)"></a>
<tr><td valign=top><li><code>$.keysOf(obj, own=false)</code><td>Shim for <code>Object.keys()</code> -- <code>own=true</code> adds <code>hasOwnProperty</code>.
<a name="$.valuesOf(obj, own=false)"></a>
<tr><td valign=top><li><code>$.valuesOf(obj, own=false)</code><td>Complement to <code>$.keysOf()</code><td>
<a name="$::eq"></a>
<tr><td valign=top><li><code>$(items).eq(i)</code><td>Return a new set with just the <code>i</code>-th item.
<a name="$::each"></a>
<tr><td valign=top><li><code>$(items).each(f)</code><td>Call <code>f(item)</code> for every item in this.
<a name="$::map"></a>
<tr><td valign=top><li><code>$(items).map(f)</code><td>Return a new set containing f(item) for every item.
<a name="$::every"></a>
<tr><td valign=top><li><code>$(items).every(f)</code><td>True if <code>f(item)</code> is true for every item.
<a name="$::some"></a>
<tr><td valign=top><li><code>$(items).some(f)</code><td>True if <code>f(item)</code> is true at least one item.
<a name="$::filterMap"></a>
<tr><td valign=top><li><code>$(items).filterMap(f)</code><td>Like <code>$(items).map()</code> except omits <code>null</code> from the result. e.g.
<pre>$(1,2,3).filterMap((x) -&gt; if (x%2) then x else null) == $(1, 3)</pre>
<a name="$::tap"></a>
<tr><td valign=top><li><code>$(items).tap(f)</code><td>Call <code>f(this)</code> and continue chaining, e.g.
<pre>$(items).tap($.log).hide()</pre>
<a name="$::reduce"></a>
<tr><td valign=top><li><code>$(items).reduce(f)</code><td> Collect <code>a</code> from <code>f(a, item)</code> for every item. The <code>a</code> and <code>f</code> arguments can be given in any order.
<pre>$(items).sum() == $(items).reduce 0, (a, x) -&gt; a + x</pre>
<pre>$(items).product() == $(items).reduce 1, (a, x) -&gt; a * x</pre>
<a name="$::union"></a>
<tr><td valign=top><li><code>$(items).union(other, strict=true)</code><td> Combine the two sets, eliminates duplicates.
<a name="$::intersect"></a>
<tr><td valign=top><li><code>$(items).intersect(other, strict=true)</code><td> Return a new set with any overlapping items.
<a name="$::distinct"></a>
<tr><td valign=top><li><code>$(items).distinct(strict=true)</code><td> Return a new set without any duplicates.
<a name="$::contains"></a>
<tr><td valign=top><li><code>$(items).contains(item, strict=true)</code><td> Return true if the item is in this set.
<a name="$::count"></a>
<tr><td valign=top><li><code>$(items).count(item, strict=true)</code><td> The number of times item appears in this set.
<a name="$::coalesce"></a>
<tr><td valign=top><li><code>$(items).coalesce()</code><td> Return the first non-null item (descends recursively into nested arrays and blings).
<a name="$::or"></a>
<tr><td valign=top><li><code>$(items).or(value)</code><td> Replace any false-y items with <code>value</code>.
<a name="$::swap"></a>
<tr><td valign=top><li><code>$(items).swap(i,j)</code><td> Swap the <code>i</code>-th and <code>j</code>-th item.
<a name="$::shuffle"></a>
<tr><td valign=top><li><code>$(items).shuffle()</code><td> Randomize the order, in-place.
<a name="$::select"></a>
<tr><td valign=top><li><code>$(items).select(property)</code><td> Collect values from sets of objects. e.g.
<pre>$(items).select('x') == $(items).map (item) -&gt; return item.x </pre>
<p>You can also pass complex nested keys, descending into objects, arrays, etc.</p>
<pre>$(items).select('someArray.2.someProperty')</pre>
<p>Selecting functions will automatically bind those functions to the site they were selected from.</p>
<pre>$(streams).select('write').call(data, "utf8")</pre>
<a name="$::zap"></a>
<tr><td valign=top><li><code>$(items).zap(property, value)</code><td> Assign <code>value</code> to <code>property</code> on every item in this.
Supports the same complex, and nested, properties that <code>$(items).select(...)</code> does.
<pre>$(items).zap('childNodes.2.style.display','none') # Hide every 3rd child</pre>
<a name="$::take"></a>
<tr><td valign=top><li><code>$(items).take(n)</code><td> Return the first <code>n</code> items from this.
<a name="$::skip"></a>
<tr><td valign=top><li><code>$(items).skip(n)</code><td> Return everything except the first <code>n</code> items from this.
<a name="$::first"></a>
<tr><td valign=top><li><code>$(items).first(n=1)</code><td> Return the first item (or the first n items if asked).
<a name="$::last"></a>
<tr><td valign=top><li><code>$(items).last(n=1)</code><td> Return the last [n] item[s].
<a name="$::slice"></a>
<tr><td valign=top><li><code>$(items).slice(start,end)</code><td> Like Array.slice() except supports negative indices, e.g.
<pre>$(items).slice(0, -2) == $(items).slice(0, items.length - 2)</pre>
<a name="$::extend"></a>
<tr><td valign=top><li><code>$(items).extend(others)</code><td> Append all the other items to this set (allows duplicates).
<a name="$::push"></a>
<tr><td valign=top><li><code>$(items).push(item)</code><td> Append item and return this (allows chaining), e.g.
<pre>$(items).push(1).push(2).reverse()</pre>
<a name="$::filter"></a>
<tr><td valign=top><li><code>$(items).filter(func, [limit], [match])</code><td> Select a new set where <code>f(item) === match</code>.
<p><code>limit</code> defaults to <code>Infinity</code>.
<p><code>match</code> defaults to <code>true</code>.
<a name="$(items).matches(expr)"></a>
<tr><td valign=top><li><code>$(items).matches(expr)</code><td> Filter the set to contain only items that:
<table>
<tr><td valign=top><li> If expr is a string, then items must be DOM nodes that match that string as a CSS selector.
<tr><td valign=top><li> If expr is a regexp, then items must be strings that match that regexp.
</table>
</li>
<a name="$(items).weave(other)"></a>
<tr><td valign=top><li><code>$(items).weave(other)</code><td> Interleave the items from the two sets.
<pre>$(1,1,1).weave($(2,2,2)) == $(2,1,2,1,2,1)</pre>
<a name="$(items).fold(f)"></a>
<tr><td valign=top><li><code>$(items).fold(f)</code><td> Stride over this set calling <code>f(a,b)</code> for each pair of items.
<pre>$(1,2,3,4).fold( (a,b) -&gt; a + b ) == $(3, 7)</pre> 
<p>This is a complement to <code>$(items).weave()</code> and they can often be used together.</p>
<a name="$(items).flatten()"></a>
<tr><td valign=top><li><code>$(items).flatten()</code><td> Flatten out any nested arrays.
<pre>$( [1,2], [3,4] ).flatten() == $(1,2,3,4)</pre>
<a name="$(items).call(args...)"></a>
<tr><td valign=top><li><code>$(items).call(args...)</code><td> Call every function in this set with <code>args...</code>.
<a name="$(items).apply(context, args...)"></a>
<tr><td valign=top><li><code>$(items).apply(context, args...)</code><td> Apply every function in this set.
<a name="$(items).log(prefix)"></a>
<tr><td valign=top><li><code>$(items).log(prefix)</code><td> Log this set to the global <code>$.log</code>.
<a name="$(items).toArray()"></a>
<tr><td valign=top><li><code>$(items).toArray()</code><td> Un-bling this set of items, returning back to a simple Array.
<a name="$(items).clear()"></a>
<tr><td valign=top><li><code>$(items).clear()</code><td> Remove all items from this.
<a name="$(items).indexWhere(f)"></a>
<tr><td valign=top><li><code>$(items).indexWhere(f)</code><td> Return the first index where <code>f(item)</code> is true
</table>

<h4>EventEmitter Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/EventEmitter.coffee">Source</a> </h4>
<p>This provides the same interface as EventEmitter API in NodeJS.
<p>It becomes available on all Bling objects, as well as a base class to use in inheritance.
<table>
<a name=".addListener"></a>
<tr><td valign=top><li><code>.addListener('event', handler)</code><td>Call <code>handler</code> every time <code>emit('event')</code> is called.
<a name=".on"></a>
<tr><td valign=top><li><code>.on('event', handler)</code><td>Synonym for <code>.addListener</code>
<a name=".emit"></a>
<tr><td valign=top><li><code>.emit('event', args...)</code><td>Causes all listeners for 'event' to be called [with arguments].
<a name=".removeListener"></a>
<tr><td valign=top><li><code>.removeListener('event', [handler])</code><td>Remove [all] listeners for this 'event'.
<a name=".removeAllListeners"></a>
<tr><td valign=top><li><code>.removeAllListeners('event')</code><td>Remove all listeners for this 'event' (unambiguously)
<a name=".listeners"></a>
<tr><td valign=top><li><code>.listeners</code><td> Get a copy of the listeners (modifying it has no effect).
<a name="$.EventEmitter.apply(object)"></a>
<tr><td valign=top><li><code>$.EventEmitter.apply(object)</code><td>Bless this object with the EventEmitter API.
</table>
<tr><td valign=top><li><code>class MyClass extends $.EventEmitter then constructor: -> super @</code><td>
<p>Every Bling instance is an EventEmitter automatically.</p>
<pre>$(items).on('data', $.log).emit('data')</pre>
<p>$.EventEmitter is an instance of it's type.</p>
<pre>$.EventEmitter.on('data', $.log).emit('data')</pre>

<h4>Async Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/async.coffee">Source</a> </h4>
<table>
<a name="$::series"></a>
<tr><td valign=top><li><code>$(funcs).series(done)</code><td> Call each function with a single argument, a
callback function.
<p>It can be very helpful to use <a href="#$.partial"><code>$.partial()</code></a> to prepare your functions so they only need the single callback as argument.
<a name="$::parallel"></a>
<tr><td valign=top><li><code>$(funcs).parallel(done)</code><td> Similar to <code>series</code>, except start all
the funcs at the same time. Each function still gets only the single callback.
</table>

<h4>Cache Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/cache.coffee">Source</a> </h4>
<p>Provides <code>$.Cache</code> that is both an instance and a type. The cache supports TTLs and fixed capacities.
<table>
<a name="Cache::new"></a>
<tr><td valign=top><li><code>cache = new $.Cache(capacity, ttl)</code><td> Create a new cache object.
<a name="Cache::has"></a>
<tr><td valign=top><li><code>cache.has(key)</code><td>
<a name="Cache::del"></a>
<tr><td valign=top><li><code>cache.del(key)</code><td>
<a name="Cache::set"></a>
<tr><td valign=top><li><code>cache.set(k, v, [ttl])</code><td>
<a name="Cache::get"></a>
<tr><td valign=top><li><code>cache.get(k)</code><td>
<a name="Cache::clear"></a>
<tr><td valign=top><li><code>cache.clear()</code><td>
</table>
<p><code>capacity</code> and <code>ttl</code> can both be <code>Infinity</code>.

<h4>Compatibility Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/compat.coffee">Source</a></h4>
<p>This plugin makes a minimal effort to cover over inconsistencies between various platforms.</p>
<table>
<a name="$.global"></a>
<tr><td valign=top><li><code>$.global</code><td> Equals 'window' in the browser, and 'global' in NodeJS.
<a name="$.global.Buffer"></a>
<tr><td valign=top><li><code>$.global.Buffer</code><td> If not defined, just add <code>Buffer.isBuffer -> false</code><td>
<a name="$.global.Map"></a>
<tr><td valign=top><li><code>$.global.Map</code><td> Fully functional shim for ES5 Map.
<a name="Math.sign"></a>
<tr><td valign=top><li><code>Math.sign(x)</code><td> 1 if positive <em>or 0</em>, -1 otherwise
<a name="String::trimLeft"></a>
<tr><td valign=top><li><code>String::trimLeft</code><td>
<a name="String::split"></a>
<tr><td valign=top><li><code>String::split</code><td>
<a name="String::lastIndexOf"></a>
<tr><td valign=top><li><code>String::lastIndexOf</code><td>
<a name="Array::join(sep)"></a>
<tr><td valign=top><li><code>Array::join(sep)</code><td>
<a name="Event::preventAll()"></a>
<tr><td valign=top><li><code>Event::preventAll()</code><td>
<a name="Element::matchesSelector"></a>
<tr><td valign=top><li><code>Element::matchesSelector</code><td>
</table>

</table>

<a name="$.config" />
<h4>Config Plugin - <a
href="https://github.com/jldailey/BlingJS/blob/master/plugins/config.coffee">Source</a>
</h4>
<p>Read text files into <code>process.env</code> to manage configuration.</p>
<table>
<a name="$.config.get"></a>
<tr><td valign=top><li><code>$.config.get(name, default)</code><td> Get a value from process.env, with a default.
<a name="$.config.set"></a>
<tr><td valign=top><li><code>$.config.set(name, value)</code><td>
<a name="$.config.parse"></a>
<tr><td valign=top><li><code>$.config.parse(data)</code><td> Parse '.env' style data into key/value pairs.
<a name="$.config.watch"></a>
<tr><td valign=top><li><code>$.config.watch(name, cb)</code><td> Call cb(prev, new) when the named value changes.
</table>

<a name="$.date" />
<h4>Date Plugin - <a
href="https://github.com/jldailey/BlingJS/blob/master/plugins/date.coffee">Source</a>
</h4>
<p>All date formats work with <code>$.date.parse()</code> and
<code>$.date.dateFormat</code></p>

<blockquote>
<table>
<tr><th>Date Format<th>Description
<tr><td valign=top>yyyy<td>Year (4)
<tr><td valign=top>YY (or yy)<td>Year (2)
<tr><td valign=top>mm<td>Month (2)
<tr><td valign=top>dd<td>Day of Month (2)
<tr><td valign=top>dw<td>Day of week (1=monday)
<tr><td valign=top>dW<td>Day of Week (Mon,Tue,etc)
<tr><td valign=top>DW<td>Day of Week (Monday,Tuesday,etc)
<tr><td valign=top>HH<td>Hour
<tr><td valign=top>MM<td>Minutes
<tr><td valign=top>SS<td>Seconds
<tr><td valign=top>MS<td>Milliseconds
<tr><td valign=top>_MS<td>MS (left padded with 0)
</table>
</blockquote>

<p>Functions</p>

<table>
<a name="$.date.defaultUnit"></a>
<tr><td valign=top><li><code>$.date.defaultUnit = "s"</code><td>Default units for timestamps if not specified.
<a name="$.date.defaultFormat"></a>
<tr><td valign=top><li><code>$.date.defaultFormat = "yyyy-mm-dd HH:MM:SS"</code><td>
<a name="$.date.stamp"></a>
<tr><td valign=top><li><code>$.date.stamp([date],[unit])</code><td>Get an integer timestamp
<a name="$.date.unstamp"></a>
<tr><td valign=top><li><code>$.date.unstamp(ts,[unit])</code><td>Convert to date object
<a name="$.date.convert"></a>
<tr><td valign=top><li><code>$.date.convert(ts,fromUnit,toUnit)</code><td>Convert between time units
<a name="$.date.midnight"></a>
<tr><td valign=top><li><code>$.date.midnight(ts, [unit])</code><td>Truncate the ts to the nearest midnight
<a name="$.date.format"></a>
<tr><td valign=top><li><code>$.date.format(ts, [format], [unit])</code><td>See format table above
<a name="$.date.parse"></a>
<tr><td valign=top><li><code>$.date.parse(str, [format], [unit])</code><td>See format table above
</table>

<h4>Debug Plugin - <a
href="https://github.com/jldailey/BlingJS/blob/master/plugins/debug.coffee">Source</a>
</h4>
<p>Useful debugging functions.</p>
<table>
<a name="$.debugStack"></a>
<tr><td valign=top><li><code>$.debugStack(err)</code><td>Return a stack trace that includes code snippets.
<a name="$.protoChain"></a>
<tr><td valign=top><li><code>$.protoChain(obj)</code><td>Return a list of all the objects in the __proto__ chain
of an object.
</table>

<h4>Delay Plugin - <a
href="https://github.com/jldailey/BlingJS/blob/master/plugins/delay.coffee">Source</a>
</h4>
<p>The builtins <code>setTimeout</code> and <code>setInterval</code> have two problems in my
opinion, the more serious being that events which get scheduled near each other in time end up
having an undefined execution order, even if they have a well-defined prior schedule.

<p>This plugin guarantees proper order or execution, and adds the ability to pause and resume
intervals.

<table>
<a name="$.delay"></a>
<tr><td valign=top><li><code>$.delay(ms, f)</code><td>Returns <code>{ cancel: -> }</code><td>
<a name="$.interval"></a>
<tr><td valign=top><li><code>$.interval(ms, f)</code><td>Returns <code>{ cancel: -> pause: -> resume: -> }</code><td>
<a name="$.immediate"></a>
<tr><td valign=top><li><code>$.immediate(f)</code><td>Calls setImmediate or process.nextTick or
setTimeout(f, 0)
</table>

<h4>Diff Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/diff.coffee">Source</a> </h4>

<table>
<a name="$.stringDistance"></a>
<tr><td valign=top><li><code>$.stringDistance(a, b)</code><td>The minimum edit distance between two strings.
<a name="$.stringDiff"></a>
<tr><td valign=top><li><code>$.stringDiff(a, b)</code><td>The list of changes to transform a into b.
</table>

<h4>Function Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/function.coffee">Source</a> </h4>

<p>This plugin provides all sorts of reusable helper functions, as well as means for composing and preparing functions.

<table>
<a name="$.identity"></a>
<tr><td valign=top><li><code>$.identity</code><td>A static function that returns it's first argument; often useful as a stub or placeholder.
<a name="$.not(f)"></a>
<tr><td valign=top><li><code>$.not(f)</code><td>A new function that inverts the return value of <code>f</code>.
<a name="$.compose(f,g)"></a>
<tr><td valign=top><li><code>$.compose(f,g)</code><td>Return a new function that calls <code>f(g(...))</code>.
<a name="$.and(f,g)"></a>
<tr><td valign=top><li><code>$.and(f,g)</code><td>Return a new function equivalent to <code>f(...) and g(...)</code>.
<a name="$.once(f)"></a>
<tr><td valign=top><li><code>$.once(f)</code><td>Return a new function that will only call <code>f</code> at-most once.
<a name="$.cycle(functions...)"></a>
<tr><td valign=top><li><code>$.cycle(functions...)</code><td>Return a new function that calls each function in a cycle. e.g.
<pre>g = $.cycle( (-> 1), (-> 2) )</pre>
<pre>[ g(), g(), g(), g() ] == [ 1, 2, 1, 2 ]</pre>
<tr><td valign=top><li><code>$.bound(context, f)</code><td>Return a new function whose context is fixed. Equivalent to <code>f.bind(context)</code> on platforms where <code>Function::bind</code> is defined.
<a name="$.partial" />
<tr><td valign=top><li><code>$.partial(f, arguments...)</code><td>Return a new function with the first few arguments to <code>f</code> pre-determined.
<pre>log = $.partial $.log, "prefix:"</pre>
<pre>log("foo") == $.log("prefix:", "foo")</pre>
<p><b>Mnemonic:</b> you are "partially" calling the function, and you get back a partially-called function.
</table>

<h4>Hash Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/hash.coffee">Source</a> </h4>

<table>
<tr><td valign=top><li><code>$.hash(anything)</code><td>Returns an integer
<tr><td valign=top><li><code>$(items).hash()</code><td>Same as <code>$.hash($(items))</code><td>
</table>
<p>Extending the <code>$.hash</code> system uses the <a href="#types"><code>$.type</code></a> system.
<pre>$.type.extend "foo", hash: (o) -> return 1234</pre>
<p>This will allow <code>$.hash()</code> to recognize and handle objects of type "foo".</p>

<h4>Hook Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/hook.coffee">Source</a> </h4>

<p>Named lists of functions are used as pipelines to process values.

<table>
<tr><td valign=top><li><code>hook = $.hook()</code><td>Create a new (empty) hook.
<tr><td valign=top><li><code>hook.append(f)</code><td>Add a function to the pipeline (at the end).
<tr><td valign=top><li><code>hook.prepend(f)</code><td>Add a function to the pipeline (at the front).
<tr><td valign=top><li><code>hook(args...)</code><td>Invoke the hook, something like calling <code>fn(...f3(f2(f1(args...))))</code><td>
</table>

<p><b>Special:</b> The hook plugin creates a special global hook: <code>$.init</code> that gets used when creating new Bling objects.
<p>One can use this to modify or extend Bling objects upon creation, e.g.
<pre>$.init.append (obj) -> $.extend obj, { magic: "marker" }</pre>
<p>Later...
<pre>$(1,2,3).magic == "marker"</pre>

<h4>Index Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/index.coffee">Source</a> </h4>

<p>Add the ability to index a set of objects, and then query against those indexes.

<table>
<tr><td valign=top><li><code>$(items).index(function)</code><td>Create an index, where function is a "key maker". e.g. <code>$(items).index (obj) -> obj.id</code><td>
<tr><td valign=top><li><code>$(items).query(criteria)</code><td>Returns the list of items that match the criteria.
<tr><td valign=top><li><code>$(items).queryOne(criteria)</code><td>Return the first matching item.
</table>
Example:
<pre>
$(items).index (obj) -> obj.id # index objects by the id field
$(items).query({ id: "a" }) # returns all items with { id: "a" }
</pre>

<h4>Dump Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/json.coffee">Source</a> </h4>

<p>Provides <code>$.toHTML</code> which acts like 'cfdump', and displays any JSON-like object as HTML.

<table>
<tr><td valign=top><li><code>$.toHTML(obj)</code><td>Returns a string
</table>

<h4>Key Names Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/keyNames.coffee">Source</a> </h4>

<p>Provides friendly mappings between keyboard codes and key names.

<table>
<tr><td valign=top><li><code>$.keyName(13) == "Enter"</code><td>See the Source for a full list of codes supported.
<tr><td valign=top><li><code>$.keyCode("Enter") == 13</code><td>
</table>
<pre>
$(item).on 'keydown', (evt) ->
	switch $.keyName(evt.keyCode)
		when "Enter" then ...
		when "Esc" then ...
</pre>

<h4>Logging Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/log.coffee">Source</a> </h4>

<table>
<tr><td valign=top><li><code>$.log(arguments...)</code><td>Log all the things (to stdout by default).
<tr><td valign=top><li><code>$.log.out = (arguments...) -></code><td>Hijack the output of <code>$.log()</code><td>
<tr><td valign=top><li><code>$.log.enableTimestamps(verbosity=2)</code><td>Start prepending the current time to each line in the log.
	<table>
	<tr><th>Verbosity<th>Prefix
	<tr><td align=center>0<td>
	<tr><td align=center>1<td>Unix Timestamp (<a href="#$.now">$.now</a>)
	<tr><td align=center>2<td>yyyy-mm-dd HH:MM:SS._MS <see>$.date</see>
	</table>
<p>Applications that will be logging at high-volume should not set <code>verbosity=2</code>.
</table>

<h4>Matches Plugin - <a href="https://github.com/jldailey/BlingJS/blob/master/plugins/matches.coffee">Source</a> </h4>

<p>This defines <code>$.matches</code> which can match pattern objects against test objects.

<table>
<tr><td valign=top><li><code>$.matches(pattern, obj)</code><td>Return true/false if the pattern matches.

<table>
<tr><th>Pattern<th>Matches
<tr><td valign=top>42<td>The value 42, an array, or a bling, containing 42.
<pre>
$.matches(42, $.range(0,50)) == true
</pre>
<tr><td valign=top>'value'<td>The string 'value', an array, or a bling, containing the string 'value'.
<tr><td valign=top>/regexp/<td>Any string that matches the regexp, or any array, or bling, that contains a string that matches. e.g.
<pre>
$.matches(/Wednesday/, fullDateString)      == true
$.matches({ name: /^Fri/ }, [ ...days... ]) == true
</pre>
<tr><td valign=top>{ key: 'value' }<td>Match any object with this key/value pair (or inside an array matches).
<tr><td valign=top>{ $any: true }<td>Matches anything (wildcard). Examples,
<pre>
$.matches({ $any: true }, { x: 1, y: 2 })         == true
$.matches({ foo: { $any: true }}, { x: 1, y: 2 }) == false
$.matches({ foo: { $any: true }}, { foo: "bar" }) == true
</pre>
<tr><td valign=top>{ $type: name }<td>Matches an object where <code>$.is(name, obj) == true</code>, <see>$.is</see>.
<tr><td valign=top>{ $class: name }<td>Matches an object where <code>$.isType('EventEmitter', obj)</code>/
<tr><td valign=top>{ $lt: &lt;N&gt; }<td>Matches any number &lt; &lt;N&gt;.
<tr><td valign=top>{ $lte: &lt;N&gt;}<td>Matches any number &lt;= &lt;N&gt;.
<tr><td valign=top>{ $gt: &lt;N&gt; }<td>Matches any number &gt; &lt;N&gt;.
<tr><td valign=top>{ $gte: &lt;N&gt; }<td>Matches any number &gt;= &lt;N&gt;.
</table>

</table>


</body>
</html>
