<html>
<head>
	<title>BlingJS Framework.</title>
	<meta name="viewport" content="initial-scale=1.0, user-scalable=yes, width=device-width" />
	<link rel="icon" href="html/bling.png" type="image/png" />
	<script src="bling.js" type="text/javascript"></script>
	<script src="plugins/bling.doc.js" type="text/javascript"></script>
	<style type="text/css">
		body {
			font-family: Verdana, sans;
			font-size: 16px;
			width:320px;
			padding:10px;
			margin-left:auto;
			margin-right:auto;
			border-right:1px dashed #cbcbcb;
			border-left:1px dashed #cbcbcb;
			background-color:white;
		}
		b { color:#800; }
		i { color:#822; }
		p {
			width:300px;
			text-align: left;
			margin-left:auto;
			margin-right:auto;
		}
		.bln {
			color: #800;
			font-size: 17px;
		}
		code.pp, textarea {
			font-family: courier, sans;
			font-size:12px;
			line-height:1.1em;
			padding:6px 0px 6px 4px;
			display: inline-block;
			border:1px dashed gray;
			background-color:#ffc;
			width:300px;
			margin:0px 0px 0px 10px;
		}
		code {
			font-family: courier, sans;
			font-size: 16px;
		}
		h3, h4, h5 {
			border-bottom: 1px solid black;
		}
		h5 {
		}
		ol.apilist {
			padding:0px 2em;
		}
		ol.apilist li {
			padding: 0px;
			margin:0px;
			border-bottom:0px dashed black;
		}
		ol.apilist li pre {
			display: none;
			margin-left: -25px;
		}
		ol.apilist li > a, 
		a[href] {
			font-size: 16px;
			text-decoration:none;
			color:blue;
			border-bottom: 1px solid black;
		}
		ol.apilist li > a span {
			margin-right:.2em;
		}

		div.doc {
			position: absolute;
			display: block;
			padding: 0;
			margin: 0;
			z-index: 9001;
			left: 0px;
		}
		div.doc pre {
			font-size:0.8em;
			margin: 0px;
			border: 1px solid navy;
			background: #f0f0f0;
			-webkit-border-radius: 6px;
		}
		div.doc h5 {
			margin: 4px;
			color: white;
		}
		div.shadow {
			position: absolute;
			display: block;
			background-color: rgba(0,0,0,.35);
			z-index: 9000;
		}
		div.shadow.solid {
			background-color: rgba(89,89,89,1);
		}
		div.shadow span {
			display:block;
			width: 200px;
			margin-left:auto;
			margin-right:auto;
			color:white;
			font-size:28px;
		}

		span.adv {
			color:blue;
		}
		span.footnote {
			font-size:0.7em;
		}

		div.dialog {
			padding:20px;
			min-width:200px;
			max-width:320px;
			min-height:60px;
			margin-left:auto;
			margin-right:auto;
			background-color: rgba(175,175,175,0.9);
			border-radius: 5px;
		}
		div.dialog pre {
			margin-left: auto;
			margin-right: auto;
		}
		div.dialog .buttons {
			position:absolute;
			bottom:1px;
			border-top:1px solid #ab7b7b;
			clear: both;
			padding:4px 10px;
		}
		div.dialog .buttons button {
			float:left;
			margin: 4px 3px;
		}
		textarea {
		}
		table.small {
			font-size: 14px;
			width: 100%;
		}
		table.small td:first-child {
			font-family: 'Inconsolata', courier, fixed, sans;
			font-size: 16px;
			width: 45%;
		}
		table.download a {
			border-bottom: 0px !important;
			text-decoration: none;
		}
		table.download td:first-child + td + td {
			text-align: right;
		}
	</style>
	<script>
		$(document).ready(function() {
			// find unsupported fraction markup
			// and insert a fall-back
			var num_re = /&frac(\d)(\d);/
			$("p").each(function() {
				var p = $(this),
					text = p.text()[0]
				if( num_re.test(text) ) {
					p.text(text.replace(num_re, "$1/$2"))
				}
			})
		})

		$(document).ready(function(){
			var initial_tab = /(^|\n)\t/g,
				all_tabs = /\t/g

			// replace tabs with spaces in <pre>'s
			// make all <pre>'s pretty-printable
			$("pre").each(function(){
				var html = this.innerHTML.replace(initial_tab,'$1').replace(all_tabs,"  ")
				html = $.HTML.escape(html)
				this.innerHTML = Function.PrettyPrint(html)
				// $(this).replace($(Function.PrettyPrint(html)))
			})
			// clean up textarea's also
			$("textarea").each(function() {
				this.value = this.value
					.replace(initial_tab,'$1')
					.replace(all_tabs, "  ")
			})
			// all documentation links are made active
			// collect the links
			var a = $("a[href^='#doc:']")
			// modify their hrefs
			a.zap('href', a.map(function() {
				return 'html/doc.html#' 
					+ this.href.split(/#doc:/)[1]
			}))
		})

	</script>
</head>
<body>
	<h1><a name="top">BlingJS</a><h1>
	<h2>A JavaScript framework for WebKit.</h2>

	<p>BlingJS is named after the <span class='bln'>$</span> symbol, which is the default alias for the Bling constructor.
	<pre>
	$("body").append('<div></div>'); </pre>

	<h3>Download</h3>
	<table class='download'>
		<tr>
			<td><a href="../bling.js">Full Source</a><td><td>[80k]
		<tr>
			<td><a href="min.bling.js">Minified</a><td><td>[28k]
		<tr>
			<td><a href="min.bling.js.gz">Compressed</a><td><td>[<b>9k</b>]
	</table>
	<p class='small'>About &frac13;rd the size of jQuery.<br> (compare v1.4.4: 179k, 78k, 28k)</p>
	<script>
		$("table.download")
			.find("td:first-child + td")
			.attr("width", "100%")
			.css("border-bottom", "1px dotted black")
	</script>

	<h3>Introduction</h3>
	<p><i>A Bling</i> is an ordered collection of items of any type.  
	This set defines functional operations to collect and manipulate the members.
	<p>You create a set by wrapping up or selecting other items, sets, or subsets:
	<pre>
	$("button") // css expressions
	$("<button>OK</button>") // or html
	$([1, "foo", {a: 'b'}]) // or anything</pre>
	<p>You then manipulate these sets using functional primitives and other operations.
	<pre>
	$("button").each(function visit(node) {
		this === node
	})</pre>


	<h4>What makes BlingJS special?</h4>
	<p>Sets.
	<p>BlingJS is similar to jQuery, with an emphasis on sets.
	<p>BlingJS operations <b>always <i>try</i> to return a set</b>.
	<p>If you want just one element, then consider using <a href='#doc:first'>first</a>, or <a href='#doc:last'>last</a>, or standard array notation; <code>[i]</code>.
	Even methods that return scalar values (like <a href='#doc:width'>width</a> or <a href='#doc:height'>height</a>), return a set of scalar values.
	<p>For complete documentation of everything BlingJS can do, see the <a href="html/doc.html">API Documentation</a>

	<a name="set" />
	<h4>Set Operations</h4>

	<p>In order to make this set-focused philosophy work, a few unique tools are provided.

	<a name="zip" />
	<p>The <a href='#doc:zip'>zip</a> operation selects an array of property values from a set of objects.
	<p>The expression...
	<pre>
	$("div").zip("style")</pre>
	<p>...will return a set of StyleDeclaration objects, one for each div on the page.
	<p>You can also zip compound names in order to extract nested properties.
	<pre>
	$("div").zip("style.setProperty")</pre>

	<p>The above example also shows another useful feature of <a href='#doc:zip'>zip</a>:
	<blockquote>When <a href='#doc:zip'>zip</a> selects a function, it is bound to the object it is selected from.</blockquote>
	<p>What this means is that when you call <code>.zip("style.setProperty")</code> you get back a set of functions.
	When you call these functions, it is the same as calling <code><i>this</i>.style.setProperty()</code> directly on each element of the set.
	<p>The <a href='#doc:call'>call</a> operation exists to help you call all the functions in the set with the same arguments.

	<p>If you specify multiple columns, you get a list of simple objects with only the desired fields.
	<pre>
	$("div").zip("id", "className")
	== $([{'id':..., 'className':... },...])</pre>

	<a name="zap" />
	<p>Naturally, <a href='#doc:zap'>zap</a> is the companion to <a href='#doc:zip'>zip</a>.  
	The <a href='#doc:zap'>zap</a> operation allows assignment in a functional syntax.
	<pre>
	$("span").zap("innerText", "Hello World")</pre>
	<p>Like <a href='#doc:zip'>zip</a>, it also supports compound properties.
	<pre>
	$("span").zap("style.color", "red")</pre>
	<p>Or, you can assign multiple properties at once.
	<pre>
	$("span").zap({
		"style.color": "red",
		"innerText": "Error"
	})</pre>
	<p>You can assign a different value to the same property on each item.
	<pre>
	$("span").take(3).zap("style.color",
		["red", "green", "blue"])</pre>

	<a name="html" />
	<h4>Html Operations</h4>
	<p>While BlingJS has all of the basic HTML and DOM manipulating operations that jQuery has (like <a href='#doc:html'>html</a>, <a href='#doc:text'>text</a>, <a href='#doc:after'>after</a>, <a href='#doc:append'>append</a>, <a href="html/doc.html#html">etc.</a>), 
	it also has two powerful ways to generate content: synth, and template.

	<a name="template" />
	<h5>Templates</h5>
	<p>Built into the core is a simple template system, and it works by replacing substrings: 
	<code>%(id)d</code>, <code>%(name)s</code>, and <code>%(dollars).2f</code> (similar to python substitution strings)
	<p>Templates can start with DOM nodes, or with raw strings.
	<textarea style="height:90px" >
	<li id="line-template">
	 <span>%(title)s</span>
	 <div>%(body)s</div>
	</li>
	</textarea>
	<p>Once you have the DOM nodes you want to copy, you should usually initialize them with <a href='#doc:template'>template</a>.
	<pre>
	$("#line-template").template({
		title: "default title",
	})</pre>
	<p>Initializing the nodes with <a href='#doc:template'>template</a> will set default values for the fields, and will remove the nodes from the DOM so that their un-rendered forms don't interfere with the page.
	<p>The <a href='#doc:render'>render</a> operation creates new nodes from templates.
	<pre>
	$("#line-template").render({
		title: "This is my line."
		body: "This is my line's body."
	})</pre>
	<p>The initialization with <a href='#doc:template'>template</a> is optional, otherwise you will have to manage the source nodes and defaults yourself.

	<a name="synth" />
	<h5>Synthesizing nodes</h5>

	<p>Given a CSS expression, <code>$.synth(css)</code> will return the smallest DOM tree that satisfies the expression.
	<p>One of the handiest features in Bling, <a href='#doc:synth'>synth</a> lets you fabricate small DOM trees, 
	using the same CSS expression that will define the nodes later.
	<p>Example:
	<pre>
	$.synth("div#foo.bar")
	== $('<div id="foo" class="bar"></div>')</pre>
	<p>The above example used the global <code>$.synth()</code>, for creating nodes that are initially un-attached to anything.  
	If you use <code>$(selector).synth(...)</code>, the new nodes will be appended to <code>$(selector)</code> before they are returned.
	<p>The <a href='#doc:synth'>synth</a> operation supports only a few CSS selectors:
	<table class="small">
		<tr><td><i>.class</i> &lt;dot&gt;<td>any number
		<tr><td><i>#id</i> &lt;hash&gt;<td>once
		<tr><td><i>[attr=val]</i><td>any number
		<tr><td><i>+</i> &lt;plus&gt;<td>between nodes
		<tr><td><i>"quote"</i><td>after a node
	</table>
	<p>It supports the non-standard quote operator <code>["']</code> for adding text nodes, like in this example:
	<pre>
	$.synth('div "Hello" p "World"')
	== $('<div>Hello<p>World</p></div>')</pre>
	<p>If the adjacency operator [+] is not clear, you can think of it as a closing tag for the currently open tag,
	like in the following example the [+] will close the open &lt;b&gt; tag.
	<pre>
	$.synth('p b "Hello" + i "World"')
	== $('<p><b>Hello</b><i>World</i></p>')</pre>
	<p>Even though this is only a small subset of CSS selectors, you can still construct an aribtrary DOM tree by combining the supported selectors.

	<h5>Synthing templates</h5>
	<p>You can use <a href="#doc:synth">synth</a> to fabricate templates quickly in code.
	<pre>
	var paragraph = 
		$.synth('p b "%(title)s" + i "%(body)s"')
			.template({
				title: "Default Title",
				body: "Default Body"
			})
	// ... sometime later ...
	$("body").append(paragraph.render({
		title: "This is my title."
		body: "This is my paragraph's body."
	})) </pre>
</body>
</html>
