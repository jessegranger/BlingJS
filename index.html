<html>
<head>
	<title>BlingJS Framework.</title>
	<meta name="viewport" content="initial-scale=1.0, user-scalable=yes, width=device-width" />
	<link rel="icon" href="html/bling.png" type="image/png" />
	<script src="dist/bling.js" type="text/javascript"></script>
	<script src="plugins/bling.doc.js" type="text/javascript"></script>
	<style type="text/css">
		body {
			font-family: Verdana, sans;
			font-size: 16px;
			width:320px;
			padding:10px;
			margin-left:auto;
			margin-right:auto;
			border-right:1px dashed #cbcbcb;
			border-left:1px dashed #cbcbcb;
			background-color:white;
		}
		b { color:#800; }
		i { color:#822; }
		p {
			width:300px;
			text-align: left;
			margin-left:auto;
			margin-right:auto;
		}
		.bln {
			color: #800;
			font-size: 17px;
		}
		h1 .bln {
			font-size: 34px;
		}
		code.pp, textarea {
			font-family: courier, sans;
			font-size:14px;
			line-height:1.1em;
			padding:6px 0px 6px 4px;
			display: inline-block;
			border:1px dashed gray;
			background-color:#ffc;
			width:300px;
			margin:0px 0px 0px 10px;
		}
		code {
			font-family: courier, sans;
			font-size: 16px;
		}
		.bold { font-weight: bold; }
		.right { text-align: right; }
		.center { text-align: center; }

		h3, h4, h5 {
			border-bottom: 1px solid black;
		}

		table.small {
			font-size: 14px;
			width: 100%;
		}
		table.small td:first-child {
			font-family: 'Inconsolata', courier, fixed, sans;
			font-size: 16px;
			width: 45%;
		}
		table.synthops {
			margin-top: 1em;
		}
		table.download {
			margin: 0 2em 0 1em;
		}
		table.download a {
			text-decoration: none;
		}
		table.download td:first-child + td {
			width: 100%;
		}
		table.download td:first-child + td + td {
			text-align: right;
		}
		a[href] { color: blue; }
		a[href]:visited { color: blue; }
		a[href]:hover { color: red; }

		a[href^=mailto] {
			text-decoration: none;
		}
	</style>
	<script>
		try {
			$(document).ready(function () {
				// find unsupported fraction markup
				// and insert fall-back text
				var num_re = /&frac(\d)(\d);/
				$("p").each(function() {
					var p = $(this),
						text = p.text()[0]
					if( num_re.test(text) )
						p.text(text.replace(num_re, "$1/$2"))
				})
			})
			.ready(function (){
				var initial_tab = /(^|\n)\t/g,
					all_tabs = /\t/g

				// replace tabs with spaces in <pre>'s
				// make all <pre>'s pretty-printable
				$("pre").each(function(){
					var html = this.innerHTML
						.replace(initial_tab,'$1')
						.replace(all_tabs,"  ")
					html = $.HTML.escape(html)
					this.innerHTML = Function.PrettyPrint(html)
				})
				// clean up textarea's also
				$("textarea").each(function() {
					this.value = this.value
						.replace(initial_tab,'$1')
						.replace(all_tabs, "  ")
				})
				// all documentation links are made active
				// collect the links
				var a = $("a[href^='#doc:']")
				// modify their hrefs
				a.zap('href', a.map(function() {
					return 'html/doc.html#' 
						+ this.href.split(/#doc:/)[1]
				}))
			})
		} catch ( err ) {
			alert("JavaScript error:" + err)
		}
	</script>
</head>
<body>
	<h1><a name="top"><span class='bln'>$</span>(BlingJS)</a><h1>
	<h2>A JavaScript library</h2>
	<div class="bold">by <a href="mailto:jesse.dailey+blingjs@gmail.com">Jesse Dailey</a></div>

	<p>BlingJS is named after the "<span class='bln'>$</span>", the default alias for the constructor.
	<pre>
	$("body").append('<div></div>'); </pre>

	<h3>Download</h3>
	<table class='download' cellspacing="0">
		<tr>
			<td><a href="dist/bling.js">Full Source</a><td><td>[62k]
		<tr>
			<td><a href="dist/min.bling.js">Minified</a><td><td>[30k]
		<tr>
			<td><a href="dist/min.bling.js.gz">Compressed</a><td><td>[<b>9k</b>]
	</table>
	<p class='small'>About &frac13;rd the size of jQuery.<br> (compare v1.4.4: 179k, 78k, 28k)</p>

	<h3>Introduction</h3>
	<p><i>BlingJS</i> defines operations to collect and manipulate sets.
	<p>You create a set by wrapping up or selecting other items, sets, or subsets:
	<pre>
	$("button") // css expressions
	$("<button>OK</button>") // or html
	$([1, "foo", {a: 'b'}]) // etc.</pre>
	<p>You then manipulate these sets using functional primitives and other operations.
	<pre>
	$("button").each(function (node) {
		this === node
	})</pre>


	<h4>What makes BlingJS special?</h4>
	<p>Sets.
	<p>BlingJS is similar to jQuery, with an emphasis on sets.
	<p>Operations <b>always <i>try</i> to return a set</b>.
	<p>If you want just one element, then consider using 
	<a href='#doc:first'>first</a>, 
	<a href='#doc:last'>last</a>,
	<a href="#doc:eq">eq</a>, or standard array notation; <code class="bold">[i]</code>.
	<p>Even methods that return scalar values (like <a href='#doc:width'>width</a> or <a href='#doc:height'>height</a>), return <b>a set of scalar values</b>.
	<p>For complete documentation of everything BlingJS can do, see the <a href="html/doc.html">API Documentation</a>

	<a name="set" />
	<h4>Set Operations</h4>

	<p>In order to make this set-focused philosophy work, a few unique tools are provided.

	<a name="zip" />
	<p>The <a href='#doc:zip'>zip</a> operation selects an array of property values from a set of objects.
	<p>The expression...
	<pre>
	$("div").zip("style")</pre>
	<p>...will return a set of StyleDeclaration objects, one for each div on the page.
	<p>You can also zip compound names in order to extract nested properties.
	<pre>
	$("div").zip("style.setProperty")</pre>

	<p>The above example also shows another useful feature of <a href='#doc:zip'>zip</a>:
	<blockquote>When <a href='#doc:zip'>zip</a> selects a function, it is bound to the object it is selected from.</blockquote>
	<p>What this means is that when you call <code>.zip("style.setProperty")</code> you get back a set of functions.
	When you call these functions, <code><i>this</i>.style.setProperty()</code> will be called on the respective div(s).
	<p>The <a href='#doc:call'>call</a> operation exists to help you call all the functions in the set with the same arguments.

	<p>If you specify multiple columns, you get a list of simple objects with only the desired fields.
	<pre>
	$("div").eq(0).zip("id", "className")
	== $([{'id':..., 
	       'className':... 
	      }])</pre>

	<a name="zap" />
	<p>Naturally, <a href='#doc:zap'>zap</a> is the companion to <a href='#doc:zip'>zip</a>.  
	The <a href='#doc:zap'>zap</a> operation allows assignment in a functional syntax.
	<pre>
	$("span").zap("innerText", "Hello")</pre>
	<p>Like <a href='#doc:zip'>zip</a>, it also supports compound properties.
	<pre>
	$("span").zap("style.color", "red")</pre>
	<p>Or, you can assign multiple properties at once.
	<pre>
	$("span").zap({
		"style.color": "red",
		"innerText": "Error"
	})</pre>
	<p>You can assign a different value to the same property on each item.
	<pre>
	$("span").take(3).zap("style.color",
		["red", "green", "blue"])</pre>

	<a name="html" />
	<h4>Html Operations</h4>
	<p>While BlingJS has all of the basic HTML and DOM manipulating operations that jQuery has (like <a href='#doc:html'>html</a>, <a href='#doc:text'>text</a>, <a href='#doc:after'>after</a>, <a href='#doc:append'>append</a>, <a href="html/doc.html#html">etc.</a>), 
	it also has two powerful ways to generate content: synth, and template.

	<a name="template" />
	<h5>Templates</h5>
	<p>Built into the core is a simple template system, and it works by replacing substrings: 
	<code>%(id)d</code>, <code>%(name)s</code>, and <code>%(dollars).2f</code> (similar to python substitution strings)
	<p>Templates can start with DOM nodes, or with raw strings.
	<textarea style="height:90px" >
	<li id="line-template">
	 <span>%(title)s</span>
	 <div>%(body)s</div>
	</li>
	</textarea>
	<p>Once you have the source you want to copy, you should usually initialize them with <a href='#doc:template'>template</a>.
	<pre>
	$("#line-template").template({
		title: "default title",
	})</pre>
	<p>Initializing the nodes with <a href='#doc:template'>template</a> will set default values for the fields, and will remove the nodes from the DOM so that their un-rendered forms don't interfere with the page.
	<p>The <a href='#doc:render'>render</a> operation creates new nodes from templates.
	<pre>
	$("#line-template").render({
		title: "This is my line."
		body: "This is my line's body."
	})</pre>
	<p>The initialization with <a href='#doc:template'>template</a> is optional, otherwise you will have to manage the source and defaults yourself.

	<a name="synth" />
	<h5>Synthesizing nodes</h5>

	<p>Given a CSS expression, <code><span class='bln'>$</span>.synth(css)</code> will return the smallest DOM tree that satisfies the expression.
	<p>The beauty of the <a href="#doc:synth">synth</a> feature lies in the fact 
	that you use the same expressions to create content that you will use to search for it.
	<p>Example:
	<pre>
	$.synth("input[type=text]#foo")
	== $('<input type="text" id="foo"/>')</pre>
	<p>The above example used the global <code><span class='bln'>$</span>.synth()</code>, 
	for creating nodes that are initially un-attached to anything.  
	If you use <code><span class='bln'>$</span>(selector).synth(...)</code>, 
	the new nodes will be appended to <code><span class='bln'>$</span>(selector)</code> 
	before they are returned.
	<p>The <a href='#doc:synth'>synth</a> operation supports only a few CSS selectors:
	<table class="small synthops">
		<tr><td><i>.class</i> &lt;dot&gt;<td>any number
		<tr><td><i>#id</i> &lt;hash&gt;<td>once
		<tr><td><i>[attr=val]</i><td>any number
		<tr><td><i>+</i> &lt;plus&gt;<td>between nodes
		<tr><td><i>"quote"</i><td>after a node
	</table>
	<p>It supports the non-standard quote operator <code>["']</code> for adding text nodes, like in this example:
	<pre>
	$.synth('p "Hello" span "Bob"')
	== $('<p>Hello<span>Bob</span></p>')</pre>
	<p>If the adjacency operator [+] is not clear, you can think of it as a closing tag for the currently open tag.

	<p>Consider the example...
	<pre>
	$.synth('p b "Hello" + i "Bob"')
	== $('<p><b>Hello</b><i>Bob</i></p>')</pre>
	<p>Here, the <code>+</code> will close the <code>&lt;b&gt;</code> tag. 
	Using multiple <code>+</code>'s in a row is meaningless when <b>matching</b> CSS patterns,
	but when <b>synthing</b> them, it does the natural thing: close multiple open nodes.
	<pre>
	$.synth('p b "Hello" + + i "Bob"')
	== $(['<p><b>Hello</b></p>',
	      '<i>Bob</i>'])</pre>
	<p>Notice that since this expression specified a fragment (without a single root), 
	it created a list of nodes.
	<p>In this way, any arbitrary DOM tree can be specified, 
	using only the limited selectors supported by synth.

	<h5>Synthing templates</h5>
	<p>You can use <a href="#doc:synth">synth</a> to fabricate complex templates quickly in code.
	<pre>
	var paragraph = 
		$.synth('p b "%(title)s" + i "%(body)s"')
			.template({
				title: "Default Title",
				body: "Default Body"
			})
	// ... sometime later ...
	$("body").append(paragraph.render({
		title: "This is my title."
		body: "This is my body."
	})) </pre>
</body>
</html>
